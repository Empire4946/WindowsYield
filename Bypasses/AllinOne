-- GCInfo Bypasser
task.spawn(function()
    repeat task.wait() until game:IsLoaded()

    local Amplitude = 200
    local RandomValue = {-200, 200}
    local RandomTime = {.1, 1}

    local floor = math.floor
    local cos = math.cos
    local acos = math.acos
    local pi = math.pi

    local Maxima = 0

    while task.wait() do
        if gcinfo() >= Maxima then
            Maxima = gcinfo()
        else
            break
        end
    end

    task.wait(0.30)

    local OldGcInfo = gcinfo() + Amplitude
    local tick = 0

    local function getReturn()
        local Formula = ((acos(cos(pi * tick)) / pi * (Amplitude * 2)) + -Amplitude)
        return floor(OldGcInfo + Formula)
    end

    local Old = hookfunction(getrenv().gcinfo, function()
        return getReturn()
    end)
    local Old2 = hookfunction(getrenv().collectgarbage, function(arg, ...)
        local success, err = pcall(Old2, arg, ...)
        if success and arg == "count" then
            return getReturn()
        end
        return Old2(arg, ...)
    end)

    game:GetService("RunService").Stepped:Connect(function()
        local Formula = ((acos(cos(pi * tick)) / pi * (Amplitude * 2)) + -Amplitude)
        if Formula > ((acos(cos(pi * tick + 0.01)) / pi * (Amplitude * 2)) + -Amplitude) then
            tick = tick + 0.07
        else
            tick = tick + 0.01
        end
    end)

    local old1 = Amplitude
    for i, v in next, RandomTime do
        RandomTime[i] = v * 10000
    end

    while wait(RandomTime) do
        Amplitude = math.random(old1 + RandomValue[1], old1 + RandomValue[2])
        RandomTimeValue = math.random(RandomTime[1], RandomTime[2]) / 10000
    end
end)

-- Memory Bypass V1
task.spawn(function()
    repeat task.wait() until game:IsLoaded()

    local RunService = game:GetService("RunService")
    local Stats = game:GetService("Stats")

    local CurrMem = Stats:GetTotalMemoryUsageMb()
    local Rand = 0

    RunService.Stepped:Connect(function()
        local random = Random.new()
        Rand = random:NextNumber(-10, 10)
    end)

    local function GetReturn()
        return CurrMem + Rand
    end

    local _MemBypass = hookmetamethod(game, "__namecall", function(self, ...)
        local method = getnamecallmethod()

        if not checkcaller() then
            if typeof(self) == "Instance" and (method == "GetTotalMemoryUsageMb" or method == "getTotalMemoryUsageMb") and self.ClassName == "Stats" then
                return GetReturn()
            end
        end

        return _MemBypass(self, ...)
    end)

    local _MemBypassIndex = hookfunction(Stats.GetTotalMemoryUsageMb, function(self, ...)
        if not checkcaller() then
            if typeof(self) == "Instance" and self.ClassName == "Stats" then
                return GetReturn()
            end
        end
    end)
end)

-- Memory Bypass V2
task.spawn(function()
    repeat task.wait() until game:IsLoaded()

    local RunService = game:GetService("RunService")
    local Stats = game:GetService("Stats")

    local CurrMem = Stats:GetMemoryUsageMbForTag(Enum.DeveloperMemoryTag.Gui)
    local Rand = 0

    RunService.Stepped:Connect(function()
        local random = Random.new()
        Rand = random:NextNumber(-0.1, 0.1)
    end)

    local function GetReturn()
        return CurrMem + Rand
    end

    local _MemBypass = hookmetamethod(game, "__namecall", function(self, ...)
        local method = getnamecallmethod()

        if not checkcaller() then
            if typeof(self) == "Instance" and (method == "GetMemoryUsageMbForTag" or method == "getMemoryUsageMbForTag") and self.ClassName == "Stats" then
                return GetReturn()
            end
        end

        return _MemBypass(self, ...)
    end)

    local _MemBypassIndex = hookfunction(Stats.GetMemoryUsageMbForTag, function(self, ...)
        if not checkcaller() then
            if typeof(self) == "Instance" and self.ClassName == "Stats" then
                return GetReturn()
            end
        end
    end)
end)
